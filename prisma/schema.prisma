generator client {
  provider = "prisma-client-js"
}

generator kysely {
  provider     = "prisma-kysely"
  output       = "../src/types/db"
  enumFileName = "enums.ts"
  fileName     = "types.ts"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id          String   @unique @default(dbgenerated("gen_random_uuid()"))
  address     String   @unique
  xpub        String?   @unique
  nickname    String?
  createdAt   DateTime @default(now())
  profileLink String?

  Collection  Collection[]
  Purchase    Purchase[]
  Collectible Collectible[]
  Order       Order[]
}

model Collection {
  id          String   @unique @default(dbgenerated("gen_random_uuid()"))
  name        String
  creator     String?
  description String
  price       Float
  createdAt   DateTime @default(now())
  walletLimit Int     @default(1000)
  logoKey     String
  totalCount  Int      @default(0)
  mintedCount Int      @default(0)
  feeRate     Float    @default(0)

  layer_type LAYER_TYPE @default(BITCOIN_TESTNET)

  POStartDate BigInt

  status     COLLECTION_STATUS @default(UPCOMING)
  isLaunched Boolean @default(false)
  
  ownerAddress String
  User        User          @relation(fields: [ownerAddress], references: [address], onDelete: Cascade)
  Collectible Collectible[]
}

model Collectible {
  id                String             @unique @default(dbgenerated("gen_random_uuid()"))
  name              String
  createdAt         DateTime           @default(now())
  fileKey           String
  status            COLLECTIBLE_STATUS @default(ACTIVE)
  generatedPsbtTxId String?
  onHoldUntil DateTime?

  ownerAddress String?
  User    User?   @relation(fields: [ownerAddress], references: [address], onDelete: Cascade)

  collectionId String
  Collection   Collection @relation(fields: [collectionId], references: [id], onDelete: Cascade)

  transactionId String?
  Transaction   Transaction? @relation(fields: [transactionId], references: [id])
  Purchase      Purchase[]
}

model Purchase {
  id        String   @unique @default(dbgenerated("gen_random_uuid()"))
  createdAt DateTime @default(dbgenerated("now()"))

  collectibleId String
  Collectible   Collectible @relation(fields: [collectibleId], references: [id], onDelete: Cascade)

  buyerId String
  User    User   @relation(fields: [buyerId], references: [id], onDelete: Cascade)

  transactionId String
  Transaction   Transaction @relation(fields: [transactionId], references: [id], onDelete: Cascade)
}

model Order {
  order_id   String   @unique @default(dbgenerated("gen_random_uuid()"))
  status     ORDER_STATUS @default(PENDING)
  created_at  DateTime @default(dbgenerated("now()"))
  updated_at  DateTime @default(dbgenerated("now()"))
  amount     Float   @default(0)
  quantity   Int     @default(0)
  feeRate   Float   @default(0)
  network_fee Float @default(0)
  service_fee Float @default(0)
  txid String?
  layer_type LAYER_TYPE @default(BITCOIN_TESTNET)
  minting_type MINTING_TYPE @default(COLLECTIBLE)

  collection_id String?
  collectible_key String?

  funding_address String
  funding_private_key String

  user_address     String
  User       User    @relation(fields: [user_address], references: [address], onDelete: Cascade)
}

model Transaction {
  id          String             @unique @default(dbgenerated("gen_random_uuid()"))
  txid        String             @unique
  createdAt   DateTime           @default(dbgenerated("now()"))
  status      TRANSACTION_STATUS @default(TRANSACTION_UNCONFIRMED)
  Purchase    Purchase[]
  Collectible Collectible[]
}

enum COLLECTIBLE_STATUS {
  ACTIVE
  ON_HOLD
  SOLD
}

enum COLLECTION_STATUS {
  LIVE
  UPCOMING
  PAST
}

enum ORDER_STATUS {
  PENDING
  IN_QUEUE
  INSCRIBING
  INSCRIBED
  CLOSED
}

enum TRANSACTION_STATUS {
  TRANSACTION_UNCONFIRMED
  TRANSACION_CONFIRMED
  TRANSACTION_FAILED
}

enum MINTING_TYPE {
  COLLECTIBLE
  BRC20
  COLLECTION
}

enum LAYER_TYPE {
  FRACTAL
  BITCOIN
  ETHEREUM
  COORDINATE
  FRACTAL_TESTNET
  BITCOIN_TESTNET
  ETHEREUM_TESTNET
  COORDINATE_TESTNET
}
