generator client {
  provider = "prisma-client-js"
}

generator kysely {
  provider     = "prisma-kysely"
  output       = "../src/types/db"
  enumFileName = "enums.ts"
  fileName     = "types.ts"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        String     @id @default(dbgenerated("gen_random_uuid()"))
  layerId   String?
  layer     Layer?     @relation(fields: [layerId], references: [id])
  address   String     @unique
  pubkey    String?    @unique
  xpub      String?    @unique
  createdAt DateTime   @default(now())
  purchases Purchase[]
  orders    Order[]
}

model Layer {
  id         String       @id @default(dbgenerated("gen_random_uuid()"))
  name       String
  layer      LAYER        @default(FRACTAL)
  network    NETWORK      @default(TESTNET)
  users      User[]
  Collection Collection[]
}

model Order {
  id             String       @id @default(dbgenerated("gen_random_uuid()"))
  userId         String
  user           User         @relation(fields: [userId], references: [id])
  collectionId   String?
  collection     Collection?  @relation(fields: [collectionId], references: [id])
  quantity       Int
  fundingAddress String
  networkFee     Float
  serviceFee     Float
  fundingAmount  Float
  txId           String?
  privateKey     String
  createdAt      DateTime     @default(now())
  paidAt         DateTime?
  mintedAt       DateTime?
  orderType      ORDER_TYPE   @default(COLLECTIBLE)
  orderStatus    ORDER_STATUS @default(PENDING)
  orderItems     OrderItem[]
  purchase       Purchase?
}

model OrderItem {
  id       String            @id @default(dbgenerated("gen_random_uuid()"))
  orderId  String
  order    Order             @relation(fields: [orderId], references: [id])
  fileKey  String
  metadata Json?
  status   ORDER_ITEM_STATUS @default(PENDING)
}

model Collection {
  id           String          @id @default(dbgenerated("gen_random_uuid()"))
  name         String
  creator      String?
  description  String
  logoKey      String?
  supply       Int
  type         COLLECTION_TYPE @default(UNCONFIRMED)
  layerId      String?
  layer        Layer?          @relation(fields: [layerId], references: [id], onDelete: SetNull)
  launches     Launch[]
  orders       Order[]
  collectibles Collectible[]
}

model Purchase {
  id           String     @id @default(dbgenerated("gen_random_uuid()"))
  userId       String
  user         User       @relation(fields: [userId], references: [id])
  launchItemId String
  launchItem   LaunchItem @relation(fields: [launchItemId], references: [id])
  purchasedAt  DateTime   @default(now())
  order        Order      @relation(fields: [orderId], references: [id])
  orderId      String     @unique
}

model LaunchItem {
  id        String             @id @default(dbgenerated("gen_random_uuid()"))
  launchId  String
  launch    Launch             @relation(fields: [launchId], references: [id])
  fileKey   String
  metadata  Json?
  status    LAUNCH_ITEM_STATUS @default(ACTIVE)
  purchases Purchase[]
}

model Launch {
  id                 String       @id @default(dbgenerated("gen_random_uuid()"))
  collectionId       String
  collection         Collection   @relation(fields: [collectionId], references: [id])
  isWhitelisted      Boolean
  wlStartsAt         DateTime?
  wlEndsAt           DateTime?
  wlMintPrice        Float?
  wlMaxMintPerWallet Int?
  poStartsAt         DateTime
  poEndsAt           DateTime
  poMintPrice        Float
  poMaxMintPerWallet Int
  launchItems        LaunchItem[]
  wlAddresses        WlAddress[]
}

model WlAddress {
  id       String @id @default(dbgenerated("gen_random_uuid()"))
  launchId String
  launch   Launch @relation(fields: [launchId], references: [id])
  address  String
}

model Trait {
  id                String             @id @default(dbgenerated("gen_random_uuid()"))
  name              String
  collectibleTraits CollectibleTrait[]
}

model CollectibleTrait {
  id            String      @id @default(dbgenerated("gen_random_uuid()"))
  collectibleId String
  collectible   Collectible @relation(fields: [collectibleId], references: [id])
  traitId       String
  trait         Trait       @relation(fields: [traitId], references: [id])
  value         String
  rarity        Float
}

model Collectible {
  id           String             @id @default(dbgenerated("gen_random_uuid()"))
  name         String?
  collectionId String
  collection   Collection         @relation(fields: [collectionId], references: [id])
  uniqueIdx    String
  fileKey      String?
  createdAt    DateTime           @default(now())
  traits       CollectibleTrait[]
  list         List?
}

model List {
  id            String      @id @default(dbgenerated("gen_random_uuid()"))
  collectibleId String      @unique
  collectible   Collectible @relation(fields: [collectibleId], references: [id])
  sellerId      String
  buyerId       String?
  address       String
  privateKey    String
  price         Float
  listedAt      DateTime    @default(now())
  soldAt        DateTime?
  status        LIST_STATUS
}

enum ORDER_TYPE {
  TOKEN
  COLLECTIBLE
  COLLECTION
  LAUNCH
}

enum ORDER_STATUS {
  PENDING
  IN_QUEUE
  DONE
  EXPIRED
}

enum ORDER_ITEM_STATUS {
  PENDING
  IN_QUEUE
  MINTING
  MINTED
  FAILED
}

enum COLLECTION_TYPE {
  UNCONFIRMED
  LAUNCHED
  MINTED
}

enum LIST_STATUS {
  ACTIVE
  SOLD
  CANCELLED
}

enum LAUNCH_ITEM_STATUS {
  ACTIVE
  ON_HOLD
  SOLD
  CANCELLED
}

enum LAYER {
  BITCOIN
  FRACTAL
  CITREA
}

enum NETWORK {
  MAINNET
  TESTNET
}
